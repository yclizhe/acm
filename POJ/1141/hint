动态规划，dp[i][j]表示i到j的字串最少需要补多少个字符
则若str[i]==str[j]，dp[i][j]==MIN(dp[i+1][j-1]+1, dp[i][k]+dp[k+1][j]) k=i,...j-1
否则，dp[i][j]==MIN( dp[i][k]+dp[k+1][j]) k=i,....j-1
用ans[i][j]记录dp[i][j]的断开位置k，还是首尾匹配时的情况，然后递归输出

dp的顺序，第一层循环代表j-i的距离，第二层循环为i起始位置，这样保证dp[i][j]时所有距离比它小的都已经求过了
